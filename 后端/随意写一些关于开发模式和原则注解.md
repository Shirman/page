### 随意写一些关于开发模式和原则注解

> 一些模式与原则的注解。随意写，随意看，欢迎批注。


- [随意写一些关于开发模式和原则注解](#随意写一些关于开发模式和原则注解)
    - [工厂模式：](#工厂模式)
    - [**接口：**](#接口)
    - [**工厂模式：**](#工厂模式)
    - [**工厂类：**](#工厂类)
    - [**工厂方法：**](#工厂方法)
    - [**单元素模式：**](#单元素模式)
    - [**观察者模式：**](#观察者模式)
    - [**dry原则：**](#dry原则)
    - [**kiss原则：**](#kiss原则)
    - [**查询和命令分离原则：**](#查询和命令分离原则)
    - [**解耦合和迪米特法则：**](#解耦合和迪米特法则)
    - [**害羞原则：**](#害羞原则)
    - [**职责单一原则：**](#职责单一原则)
    - [**开闭原则:**](#开闭原则)
    - [**接口隔离原则：**](#接口隔离原则)
    - [**依赖标准原则：**](#依赖标准原则)
    - [**好莱坞原则：**](#好莱坞原则)
    - [**关注点分离原则：**](#关注点分离原则)
    - [### 小结：](#-小结)




#### 工厂模式：
鼓励松散耦合；
您需要一组模式，使这些类能够相互通信，但不希望将它们紧密绑定在一起，以避免出现联锁。

工厂类用于控制具有相同或类似功能的不同对象；
工厂生成一个可实现指定功能的对象，至于对象内部是怎么实现，外部不需要知道，只要知道给工厂材料，工厂提供一个类似或相同的该对象；比如有个功能就是数据的读取，有个是文件读取类，另一个是数据库读取类，只要最后工厂提供的对象可以提供操作方法来获取数据就可以了，工厂根据开发人员提供的数据，返回指定的对象即可；当要将文件读取的方式更改为数据库读取的方式时，只要修改工厂类生成数据读取对象的方式即可；

#### **接口：**

用于实现形式或处理的事情类似但内部处理行为不一样的类对象们

#### **工厂模式：**

生产不同的对象，工厂类主要负责生产不同但类似工具产品对象；

#### **工厂类：**

管理形式或处理的事情类似的类对象们；

#### **工厂方法：**

类自身中可以生成不同的对象（其实就是初始化属性不一样的对象），可采用公共静态方法返回自身对象；


#### **单元素模式：**
单元素模式可以满足此要求。如果应用程序每次包含且仅包含一个对象，那么这个对象就是一个单元素（Singleton）；

某些应用程序资源是独占的，因为有且只有一个此类型的资源。

数据库资源句柄 采用单元素 类的方式访问连接数据库，多次返回的句柄是否是一样的？避免到处创建数据库资源对象；

如果您在整个应用程序中使用数据库连接单元素，那么就可以在任何地方重用同一句柄。
怎么重用？



#### **观察者模式：**

自己有更新号码，马上通知所有的好友要更新号码（具体这些好友怎么更新是这些好友自己的事）
主线是自己，将其他对象添加到自己对象属性中(类似于人在自己的email通讯录上添加好友)，别人请求你帮忙一件事时，你可以再请求在你属性中的对象帮你实现这件事（向你的好友申请帮忙解决这件事）；



#### **dry原则：**

donnt repeat yourself
抽象抽取相同或类似的代码

#### **kiss原则：**

keep it sample and stupid
尽量保持简约，易懂


#### **查询和命令分离原则：**

查询：当一个方法返回一个值来回应一个问题的时候，它具有查询的性质
命令：当一个方法要改变对象的状态的时候，它就具有命令的性质
尽量保持清晰性


#### **解耦合和迪米特法则：**

用以下的很形象的比喻可以进一步了解这个法则：
如果你想让你的狗跑的话，你会对狗狗说还是对四条狗腿说？你只要通知狗狗run，至于狗狗的run是怎么分配四条腿的，那是狗狗自己的事了。
如果你去店里买东西，你会把钱交给店员，还是会把钱包交给店员让他自己拿？你给店员提供个get的方式才能拿到钱。


#### **害羞原则：**

一个对对其他对象的feature很感兴趣，老是羡慕别人的成员，大老远的调用别人的成员、结构，发展下去是很不合理，程序员们应该害羞点，羡慕归羡慕，调整下自己，让自己也拥有羡慕的feature。


#### **职责单一原则：**

一个类，只做一件事，并把这件事做好，且只有一个引起它变化的原因；
促使低耦合、高内聚
unix是这个原则的完美体现者，各个程序都独立负责一个单一的事件；


#### **开闭原则:**

对扩展是开放的，对修改的封闭的
增加新的需求时，可以对现有代码进行扩展
一旦设计完成，就可以独立完成其任务，不再对其进行修改，或只能修改内部实现方式，接口交互依旧不能更改；


#### **接口隔离原则：**

不同的功能或产品将不同的接口组合在一起；



#### **依赖标准原则：**

业务逻辑程序应该是依赖于标准（接口、规则），而不是两个业务对象直接对话；
插座和电器上的插头，不是各自对象对话，而是插座-》插座插头标准《-插头
依赖接口
注重接口而不是实现，接口是一种标准，依赖接口而不是实现


#### **好莱坞原则：**

意思是，好莱坞的经纪人们不希望你去联系他们，而是他们会在需要的时候来联系你。
也就是说，所有的组件都是被动的，所有的组件初始化和调用都由容器负责。组件处在一个容器当中，由容器负责管理。

简单的来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在：

不创建对象，而是描述创建对象的方式。
在代码中，对象与服务没有直接联系，而是容器负责将这些联系在一起。
控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。


#### **关注点分离原则：**

这个原则，就是在软件开发中，通过各种手段，将问题的各个关注点分开。如果一个问题能分解为独立且较小的问题，就是相对较易解决的。


#### ### 小结： ###
不过这些原则看上去都不难，但是要用好却并不那么容易。要能把这些原则用得好用得精，而不教条，我的经验如下：（我以为这是一个理论到应用的过程）

- 你可以先粗浅或是表面地知道这些原则。
- 但不要急着马上就使用。
- 在工作学习中观察和总结别人或自己的设计。
- 再回过头来了回顾一下这些原则，相信你会有一些自己的心得。
- 有适度地去实践一下。
- Goto第 3步。


> 多写点代码 ，让方法尽量简单尽量傻瓜式的调用（比如不再需要参数），大的复杂的有很多参数的函数可以更改为类的方式处理


----------
@tsingchan