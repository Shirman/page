

本文主要介绍常用的读写分离方式，和读写分离遇到的过期读问题如何解决？

读写分离的基本结构

- 客户端直连，由客户端做负载均衡
- 中间proxy架构

过期读解决方案：

- 强制走主库方案（客户端查询请求分类连接）
- sleep 方案（主库更新后，读从库之前先 sleep 一下）
- 判断主备无延迟方案
- 配合 semi-sync 方案（引入半同步复制）
- 等主库位点方案
- 等 GTID 方案


其实，在实际应用中，这几个方案是可以混合使用的。比如，先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等 GTID 或等位点的方案。但话说回来，过期读在本质上是由一写多读导致的。在实际应用中，可能会有别的不需要等待就可以水平扩展的数据库方案，但这往往是用牺牲写性能换来的，也就是需要在读性能和写性能中取权衡。

原文：https://time.geekbang.org/column/article/77636