
<!-- TOC -->

- [**DFD**](#dfd)
- [**质量属性**](#质量属性)
- [非功能性需求](#非功能性需求)
- [质量属性与非功能性需求的关系与区别](#质量属性与非功能性需求的关系与区别)
- [**风险点、敏感点、平衡点**](#风险点敏感点平衡点)
- [软件架构风格](#软件架构风格)
- [**MVC架构风格**](#mvc架构风格)
- [java构建技术](#java构建技术)
- [web应用架构设计](#web应用架构设计)
- [层次式架构设计](#层次式架构设计)
- [企业集成架构设计](#企业集成架构设计)
- [负载均衡方案](#负载均衡方案)
- [高并发优化](#高并发优化)
- [web响应式设计](#web响应式设计)
- [UML](#uml)
- [UML9大视图关系](#uml9大视图关系)
- [用例之间的关系](#用例之间的关系)
- [类及类之间的关系](#类及类之间的关系)
- [UML有哪几种类](#uml有哪几种类)
- [设计模式](#设计模式)
- [敏捷开发过程](#敏捷开发过程)
- [PHP与java的对比](#php与java的对比)
- [文件系统、关系数据库、内存数据库对比](#文件系统关系数据库内存数据库对比)
- [mysql](#mysql)
- [数据库设计](#数据库设计)
- [redis相关](#redis相关)
- [memcache与redis对比](#memcache与redis对比)
- [cache与DB的对比](#cache与db的对比)
- [引入缓存后系统访问数据的过程](#引入缓存后系统访问数据的过程)
- [**ORM**](#orm)
- [数据持久层](#数据持久层)
- [ORM方式与传统数据库访问方式对比](#orm方式与传统数据库访问方式对比)
- [SOA](#soa)
- [微服务](#微服务)
- [**ESB**](#esb)
- [SOA与微服务](#soa与微服务)
- [项目计划内容](#项目计划内容)
- [成本计算](#成本计算)
- [安全保障措施](#安全保障措施)
- [**安全与加解密**](#安全与加解密)
- [对称加解密与非对称加解密](#对称加解密与非对称加解密)
- [面向服务与面向资源的REST关系和区别](#面向服务与面向资源的rest关系和区别)
- [开发方法](#开发方法)
- [设计方法](#设计方法)
- [架构风格](#架构风格)
- [设计模式](#设计模式-1)

<!-- /TOC -->

> 时间：2019年

### **DFD**

[数据流图参考](https://blog.csdn.net/jiaolong724/article/details/7226565)

**数据流图**

DFD：数据流图，是一种图形化的系统模型，在一张图中展示信息系统的数据流向，即系统的输入与输出数据分别是什么，数据从哪里去并最终到哪里去，以及数据存储在什么地方。

**基本图形元素**

- 数据流：数据流图中描述的数据流，而不是控制流
- 加工：加工描述了输入数据流到输出数据之间的变换
- 数据存储：表示暂时存储的数据
- 外部实体：存在与系统之外的人员或组织，指出数据所需要的发源地或产生的数据归属地


需求分析阶段，为了获得读新系统的框架认识、概念性认识，需要对新系统建模。

**如何画数据流程图**

- 确定系统的输入与输出
- 由外向里画系统的顶层数据流图
- 自顶向下逐层分解，绘出分层数据流图



### **质量属性**

[系统架构质量属性](./系统架构质量属性.md)

### 非功能性需求

[系统架构非功能性需求](./系统架构非功能性需求.md)

### 质量属性与非功能性需求的关系与区别

非功能性需求通常被看做是能力，主要跟服务质量有关，也就是一个软件的质量属性

### **风险点、敏感点、平衡点**

**概念定义**

- 风险点：架构设计中潜在的、存在问题的架构决策带来的隐患，从而影响系统的某种质量属性
- 非风险点：**在一个范围内**，可接受的影响某种质量属性
- 敏感点：为了实现某种特定的质量属性，一个或多个组件所具有的特性
- 权衡点：影响多个质量属性的特性，是多个质量属性的敏感点


### 软件架构风格

**什么是架构风格：**

软件架构风格是指 **描述** 特定软件系统`组织方式`的`惯用模式`。

组织方式**描述**了系统的组成构件和这些构件的`组织方式`；惯用模式则**反映**了众多系统**共有**的`结构`和`语义`。

**各种架构风格：**

**【数据流风格】**

- **管道和过滤器**：每个构件都有一组输入与输出，数据输入构件经过内部处理，然后产生数据输出。

**【调用/返回风格】**

- **数据抽象和面向对象组织**：目前软件界已普遍使用面向对象系统，这种风格的构件是对象或说是抽象数据类型的实例

- **分层系统**：层次系统组成一个层次结构，每一层为上一层服务，并作为下层客户，内部层的接口大多只对相邻的层可见。

**【独立构件风格】**

- 进程通信架构风格

- **事件驱动系统**：构件不直接调用一个过程，而是触发或广播一个或多个事件。当一个事件触发，系统自动调用这个事件中注册的所有过程。

**【虚拟机风格】**

- 解释器架构风格

- 基于规则的系统。基于规则的系统包括规则集、规则解释器、规则/数据选择器

**【仓库风格】**

- **仓库系统及知识库**：中央数据结构说明当前状态，独立构件在中央数据存储上执行

- 黑板架构风格。黑板是一个全局数据库，包含解域的全部状态，是知识源相互作用的唯一媒介。

**【其他扩展风格】**

- **C2风格**：可以概括为通过连接件绑定在一起按照一组规则运作的并行构件网络。

- **客户/服务器风格**

即C/S风格，二层结构风格

- **三层C/S结构风格**

瘦客户端方式，三层C/S结构风格将应用功能分成表示层、功能层、和数据层三个部分

- **B/S风格**

相比于CS风格，BS有以下优点：

    1、系统安装、修改和维护升级全在服务端解决        
    2、开发简单、共享性强、扩展简单方便
    3、分布性强，客户端零维护
    
不足之处：

    1、BS安全性较难以控制
    2、用户体验比cs差些
    3、速度比cs慢
    4、处理能力相较于cs单一



### **MVC架构风格**

**定义：**

MVC架构风格：用一种`业务逻辑`、`数据`、`界面显示`分离的方法`组织代码`，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。

MVC架构将整个软件系统划分成`模型`、`视图`、`控制器`3个部分。

**模型** 应用程序的主题部分。模型表示业务数据和业务逻辑。负责维护并保存具有持久性的业务数据，实现业务处理功能，并将业务数据的变化情况及时通知视图；


**视图** 用户看到并与之交互的界面。负责呈现模型中包含的业务数据，响应模型变化通知，更新呈现形式，并向控制器传递用户的界面动作；


**控制器** 接受用户的输入并调用模型和视图去完成用户的请求。负责将用户的界面动作映射为模型中的业务处理功能，并实际调用之，然后根据模型返回的业务处理结果选择新的视图。



### java构建技术

**java2概述**

jvm->jre->j2se->j2ee->j2me

**5大构件**

Applet、Servlet/JSP、JavaBean、EJB、客户端构件

**相关关键词**

RMI、分布式对象模型、CORBA、JMS、JDBC、JTA、JTS、DAO

### web应用架构设计

详见：[web应用架构设计](./web应用架构设计.md)

### 层次式架构设计

mvc模式

- 表现层
- 中间业务逻辑层
- 数据访问层


### 企业集成架构设计



- 数据集成

    为平台上运行的各种应用、系统或服务，提供具有完整性、一致性、安全性的数据访问、信息查询及决策支持服务。

    - 数据关联
    - 数据复制
    - 基于接口数据集成

- 应用集成

    应用计划才能是指两个或多个应用系统根据业务逻辑的需要而进行的功能之间的相互调用和相互操作。

    - 适配器集成模式
    - 信使集成模式
    - 面板集成模式
    - 代理集成模式

- 企业集成

    单层到N层的企业应用软件系统架构

    - 前端集成
    - 后端集成
    - 混合集成

**企业集成关键应用技术：**

- 数据交换格式
    - EDI
    - XML
    - STEP
    - PDML
    - JSON

- 分布式应用集成基础框架
    - CORBA
    - COM+ / RPC
    - J2EE
    - Web Service(XML/UDDI/WSDL/SOAP)
    - 

### 负载均衡方案

- nginx
- lvs
- cdn

### 高并发优化

- 在客户端与web服务之间引入 **CDN**
- 在客户端与web服务之间引入 **负载均衡器**
- 在web服务与应用层之间引入 **异步消息队列**
- 在数据层引入**DB扩展机制**，如分库、分表、分区、主从复制、索引优化等
- 在应用层与数据库之间引入 **缓存机制**

### web响应式设计
概念、实现方式

响应式不是自适应

自适应根据设备的不同提供不同的多套用户界面（比如www与m），响应式只有一套用户界面

- 移动优先：从2014年开始移动设备使用访问率超过pc
- 渐进增强：通常先实现一个基础版本，在大部分设备满足基本功能后，针对性的兼容添加新功能新特性，再逐步拓展应用
- 屏幕：响应式就是响应屏幕尺寸
    
    物理尺寸：屏幕对角线，单位英寸
    逻辑尺寸：相对于物理尺寸，也叫分辨率，单位像素，使用宽x高的方式表示分辨率

    与物理像素相对应的CSS像素

**响应式实现方案**

- 流动布局+弹性布局
- 媒体查询


### UML

UML通过图形化的表示机制从多个侧面对系统的分析和设计模型机型刻画。

UML共定义了9种视图，并分为如下4类:

- `用例图`：从外部用户的角度描述系统的功能并指出功能的执行者，**强调这个系统是什么，而不是怎么工作**

- `静态图`：`类图`、`对象图`、`包图`。

    - `类图`描述了系统的静态结构；
    - `对象图`是类图的一个实例；
    - `包图`描述系统的分解结构

- `行为图`：`交互图`、`状态图`、`活动图`。它们从不同的侧面刻画系统的动态行为；
    - `交互图`描述对象之间的消息传递；
    - `状态图`描述类的对象的动态行为，包含对象的所有可能的状态及事件；
    - `活动图`描述系统为完成某项功能而执行的操作序列，包含信息流和控制流

- `实现图`：`构件图`、`部署图`。描述软件实现系统的组成和分布状况。
    - `构件图`描述软件实现系统中各组成部件及它们之间的依赖关系；
    - `部署图`描述作为软件系统运行环境的硬件及网络的物理体系结构。

*交互图还可以细化为顺序图和合作图*

参考：https://www.jianshu.com/p/0786d8f9a037


### UML9大视图关系

- 用例图：告诉我们系统是什么
- 类图：静态的，告诉我们产生什么影响，但不知道什么时候
- 对象图：是类图的具体实例图
- 包图：为了简单的表示出类图，把类组合成包packages
- 交互图：动态的，描述了对象间的交互，常用的顺序图，`对象`、`消息`、`生命线`组成，横向轴代表在协作中的类对象，纵轴是时间轴
- 状态图：描述了对象或场景的状态及相应行为，比如登录有初始、登录、成功、失败等状态
- 活动图：活动图更像是多个活动对象流程交互图，活动图也可以理解成泳道图
- 构件图：是类图的物理实现
- 部署图：运行环境的硬件及网络的物理体系结构



### 用例之间的关系


**用例：**

    用例是对一个活动者使用系统的一项功能时所进行的交互过程的一个文字描述序列。
    
    用例是系统、子系统或类和外部的参与者交互的动作序列的说明，包括可选的动作序列和会出现异常的动作序列。

    一般采用动宾结构或主谓结构命名

    比如：取款机使用、验证账号

    注：个人通俗的理解为场景，软件工程里常说用例场景

    一个用例图是角色、用例、和他们之间的联系的集合。

**用例之间的关系：**

- **泛化**：代表一般和特殊的关系，子用例继承了父用例的行为与含义，泛化关系使用空心三角形箭头的实线表示，箭头指向父用例

- **包含**：两个用例之间的关系，其中一个用例的行为包含了另一个用例的行为，包含是比较特殊的依赖关系，取款机使用包含验证账户用例。使用带箭头的虚线表示，箭头指向包含用例，同时<\<include\>>附加在虚线上

- **扩展**：基本含义与泛化类似。但在扩展关系中，对于扩展用例有更多的规则限制。使用带箭头的虚线表示，箭头指向基本用例，同时<\<extend\>>标记在虚线上


### 类及类之间的关系

**概念**

类：是具有相似`结构`、`行为`、`关系`的一组对象的抽象。

使用三个格子的长方形表示：`类名`、`属性`、`操作`

**类之间的关系**

- 依赖：两个元素，修改元素A导致元素B的修改。**虚线+实心三角形 表示**

- 关联：表示两种类的实例间的关系。**用两个类之间的 连线 表示**。

- 聚合：一种特殊形式的关联。聚合表示类之间**整体与部分**的关系。**用一个带 空心菱形的实心连线 ，空心菱形指向具有整体性质的类。**

- 组合：是一种特殊的聚合，组合关系中的整体与部分具有**同样的生存期**。可以约等于聚合+依赖关系。**实心菱形+实心连线表示。**

- 泛化：定义了**一般和特殊**元素之间的关系，也就是OOP中所说的类与类之间的继承关系。**用空心三角形的实心连线表示泛化关系，三角形指向具有父类性质的类。**

- 实现：

注：除了依赖是虚线表示，其他都是实线；空心菱形是聚合，实心菱形是组合，空心三角形是泛化；依赖是实心三角形+虚线；

### UML有哪几种类


- 1.边界类，描述外部与系统内部交互的类；

- 2.控制类，控制其他类；

- 3.实体类，存储信息和相关行为的类；

参考：https://www.cnblogs.com/dandanlovehamhamzo/p/4967980.html



### 设计模式

**原则**

- `开闭原则`：对扩展开放，对修改关闭

- `单一职责原则`：每个类的职责单一

- `里氏替换原则`：任何基类可以出现的地方，子类也可以出现

- `依赖倒置原则`：面向接口/抽象编程，依赖于抽象而不依赖于具体

- `接口隔离原则`：每个接口中不存在子类用不到，却必须实现的方法，如果不然就要拆分接口。不要大综合接口，建议分离。

- `迪米特法则`：也叫最少知道原则，一个类对自己依赖的类知道越少越好，不要去关心被依赖类的复杂度。

- `合成复用原则`：尽量使用聚合/组合的关系，而不是使用继承。

注：开闭、单一里氏、依赖接口、迪米特、合成复用

**三大类型**

- `创建型`：主要用于**创建对象**，为设计类实例化新对象提供指南。对应5种设计模式

    - Factory Method 工厂方法
    - Abstract Factory 抽象工厂
    - Builder 构建器
    - Prototype 原型
    - Singleton 单例    

- `结构型`：主要用于处理类或对象的**组合**，对类如何设计形成更大的结构提供指南。对应7种设计模式

    - Adapter 适配模式
    - Bridge 桥接模式
    - Composite 组合模式
    - Decorator 装饰模式
    - Facade 外观模式
    - Flyweight 享元模式
    - Proxy 代理模式

- `行为型`：主要用于**描述**类或对象的**交互及职责的分配**，并对类之间的交互及职责分配的方式提供指南

    - Chain of Responsibility 责任链模式
    - Command 命令模式
    - Interpreter 解释器模式
    - Iterator 迭代子模式
    - Mediator 中介者模式
    - Memento 备忘录模式
    - Observer 观察者模式
    - State 状态模式
    - Strategy 策略模式
    - Template Method 模板方法模式
    - Vistor 访问者模式

**常用具体模式**

- 工厂方法：
- 抽象工厂：DB案例
- 单例模式：懒汉与饿汉模式，详见：[11-单例模式](../互联网/开发方法与设计模式/11-单例模式.md)

- 适配器
- 策略方法
- 模板方法

详见：

[23种设计模式全解析](../互联网/开发方法与设计模式/23种设计模式全解析.md)

[概要设计模式](../互联网/开发方法与设计模式/概要理解设计模式.md)

### 敏捷开发过程

详见：[敏捷方法入门](./敏捷方法入门.md)

### PHP与java的对比

参考：https://www.cnblogs.com/liangxiaofeng/p/5255181.html


### 文件系统、关系数据库、内存数据库对比

[文件系统-关系数据库-内存数据库比较](./文件系统-关系数据库-内存数据库比较.md)


### mysql

主从、优化方案、分区等

- [数据库主从复制](https://segmentfault.com/a/1190000018404615?utm_source=coffeephp.com)

- 优化方案详见：[数据库与缓存](../互联网/数据库与缓存/index.md)

- 目前mysql的版本，建议分表，不建议分区，分区带来部分索引及列不能解决的问题

### 数据库设计

**范式**

- 第一范式：每一列（属性）不可再分割（列具有原子性）
- 第二范式：满足1nf，且属性完全依赖于主键（不产生不依赖于主键的冗余列）
- 第三范式：满足2nf，且属性不传递（间接）依赖于主键（可拆分列去冗余）

**范式的缺点**

虽然范式为数据库节省了存储空间，但范式越高，表数量越多，关联查询越多，性能越低

**反范式**

反范式也就是意味着，可以不满足3nf及更高的范式，不满足2nf，但一定会满足1nf

需求>性能>表结构

首先数据库设计要满足功能要求，再满足性能要求，最后才关心表结构（空间相关考虑）

我们可以适当的数据冗余，利用空间来换取时间，将部分数据冗余到其他表中，减少或避免不必要的表关联

**反范式缺点**

虽然反范式在查询效率上明显提升，但在写入数据时，需要考虑写入相关表数据，而不像范式只要将数据写入一个地方。（牺牲写入效率换取高性能读取）

### redis相关

- 集群cluster：相当于web服务的负载均衡器
- 主从方案：每个redis节点最好都要有一个备用节点，可以随时顶替主节点
- 切片方案：

参考：[Redis-Cluster集群](https://www.jianshu.com/p/813a79ddf932)

### memcache与redis对比

参考：[Redis和Memcache区别，优缺点对比](https://blog.csdn.net/lihua5419/article/details/91816559)


- `性能`：redis使用单核，memcache使用多核，memcache在性能上略高于redis
- `存储空间`：memcache可以修改最大内存采用LRU算法，但局限于物理内存；redis增加了vm的特性，突破了物理内存的限制
- `数据结构`：memcache数据结构单一，redis支持更多数据结构，也可以在服务端进行复杂的操作
- `可靠性`：memcache不支持持久化，重启后数据丢失；redis支持数据持久化和数据恢复，允许单点故障，但也同时付出性能上的代价
- 应用场景：都可以在动态系统中减轻数据库负载，提升性能，做缓存适合多读少写；redis更适合对读写效率高，且数据业务处理复杂及对安全性要求较高的系统




从本质上说：memcache是一个单一key-value的内存cache，redis则是一个数据结构内存数据库，支持多种数据结构，单纯缓存作用外，还能做一些简单的逻辑运算，还可以当做数据库使用

### cache与DB的对比

参考：[关系数据库与内存数据库](./文件系统-关系数据库-内存数据库比较.md)


###　引入缓存后系统访问数据的过程

- 系统需要读取后台数据时，先检查数据是否存在与缓存中
- 若存在缓存则直接读取缓存
- 若不存在则从数据库中读取，并保存到缓存中
- 当数据库中发生数据库更新时，需要将更新后的内容同步到缓存中

### **ORM**

**概念：**

ORM：对象关系映射，用于在关系数据库和业务实体对象之间作一个映射。

从效果上说，它更像是创建了一个可在编程语言里使用的虚拟对象数据库。

说白了就是把关系数据库封装成业务实体对象，这样在具体的操作业务对象的时候，就不需要再去和复杂的sql语句打交道，只需要简单操作对象的属性和方法。

ORM提供了概念性的易于理解的模型化数据的方法。


**ORM与JDBC：**

jdbc是java操作数据库的规范接口

orm是一种思想，对象关系映射

jdbc：是从底层访问数据库服务器，一般银行、金融行业为安全起见，直接使用jdbc

orm：是对象关系映射，如hibernate，让你以面向对象的方式去编程，封装了jdbc



### 数据持久层

**持久化**

即把数据保存到可永久保存的存储设备中。比如将内存中的数据存储到关系数据库中。


**持久层**

持久层即专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据使用者和数据实体相关联。

### ORM方式与传统数据库访问方式对比

**传统数据库访问方式优点：**
- 性能比ORM更好
- 可以处理更为复杂的sql语句

**传统数据库访问方式缺点：**
- 要开发熟练sql语句
- 修改与维护相对困难

**ORM方式优点：**

- 使用ORM可以大大降低学习及开发成本
- 大大提供开发效率及减少代码量
- 降低维护成本的同时，提高了代码质量
- 业务与数据解耦

**ORM方式缺点：**
- 不好处理复杂的sql语句
- 性能相对原生sql差些



### SOA

**概念定义**

SOA是一种`粗粒度`、`松耦合`、`接口标准化`服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看作是B/S模型、XML（标准通用标记语言的子集）/Web Service技术之后的自然延伸。

工程师站在更高的角度看待企业架构。面向服务是更高层次的整体架构设计，面向对象是下层单个服务的架构设计。


参考：

https://www.jdon.com/soa.html

https://blog.csdn.net/fuhanghang/article/details/83961606




### 微服务

参考：https://www.jdon.com/soa/microservice-architecture.html

https://www.cnblogs.com/wintersun/p/6219259.html

### **ESB**
企业总线概念及理念，与微服务相关


### SOA与微服务

参考：

https://blog.csdn.net/zpoison/article/details/80729052

https://www.cnblogs.com/wintersun/p/6219259.html

https://www.cnblogs.com/crazylqy/p/7954356.html


### 项目计划内容

2013年


### 成本计算
2013年


### 安全保障措施
- 防止重放攻击：挑战/应答认证
- 传输过程的完整性
- 数据一致性、不可否认性

### **安全与加解密**

### 对称加解密与非对称加解密

**对称加解密**

- 机密性：发送者利用对称密钥对要发送的数据进行加密，只有拥有正确密钥的接收者才能将数据正确解密，从而提供机密性

- 完整性：发送者根据要发送的数据生成消息认证码或摘要，利用对称密钥对消息认证码/摘要进行加密并附加到数据上发送（**生成摘要-摘要加密-附加到发送数据**）；接收者使用相同密钥将对方发送的消息认证码/摘要解密，并根据接收的数据重新生成消息认证码/摘要，比较两个认证码是否相同以验证数据的完整性（**摘要解密-重新生成摘要-摘要比对-验证结束**）。

**非对称加解密**

- 机密性：发送者利用接收者的**公钥**对要发送的数据进行加密，只有拥有对应**私钥**的接收者才能将数据正确解密，从而提供机密性。

- 完整性：发送者根据要发送的数据生成消息认证码/摘要，使用自己的**私钥**对消息认证码进行加密，并附加到数据上发送；接收者使用发送者的**公钥**解密消息认证码，并根据接收到数据重新生成消息认证码，比较两个消息认证码以验证数据的完整性






### 面向服务与面向资源的REST关系和区别


### 开发方法

### 设计方法

### 架构风格

### 设计模式

