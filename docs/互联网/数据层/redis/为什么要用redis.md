

<!-- TOC -->

- [Redis是什么](#redis是什么)
- [为什么Redis这么快](#为什么redis这么快)
- [Redis为什么是单线程的？](#redis为什么是单线程的)
- [单线程可以处理高并发请求吗？](#单线程可以处理高并发请求吗)
- [单线程无法发挥多核，如何重复利用多核cpu](#单线程无法发挥多核如何重复利用多核cpu)
- [Redis 5种数据值类型](#redis-5种数据值类型)
- [redis的常用使用场景](#redis的常用使用场景)
- [Redis的数据淘汰机制](#redis的数据淘汰机制)
- [Redis数据持久化](#redis数据持久化)
- [分片](#分片)

<!-- /TOC -->


### Redis是什么

Redis，是一种运行速度很快，并发很强，运行在内存上的NoSql数据库，支持键到五种数据类型的映射。

### 为什么Redis这么快

- 首先，**单线程操作** ，**避免了频繁的上下文切换。**   
- 其次，**采用了多路复用io阻塞机制**   
- 然后，**数据结构简单，操作节省时间**   
- 最后，**运行在内存中，自然速度快**

### Redis为什么是单线程的？

![](https://pic2.zhimg.com/v2-581ac1ca10563013cd625ac602f33e79_b.jpg)

官方给了一点解释。不过基本要点也都说了，因为Redis的瓶颈不在cpu的运行速度，而往往是网络带宽和机器的内存大小。而且单线程切换开销小，容易实现。单线程容易实现，而且CPU不会成为瓶颈，那就很好理解地采用单线程方案。


### 单线程可以处理高并发请求吗？

有一点概念需要澄清，并发并不是并行。  

- 并发性I/O流，意味着能够让一个计算单元来处理来自多个客户端的流请求。

- 并行性，意味着服务器能够同时执行几个事情，具有多个计算单元

redis是可以处理高并发请求的。


### 单线程无法发挥多核，如何重复利用多核cpu

我们使用单线程的方式是无法发挥多核CPU性能，但我们可以通过在单机开多个Redis 实例来实现。

注意：**我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理** ，一个正式的Redis Server运行的时候肯定是不止一个线程的。

例如Redis进行持久化的时候会以子进程或者子线程的方式执行

### Redis 5种数据值类型

- **String 整数，浮点数或者字符串**   
- **Set 集合**   
- **Zset 有序集合**   
- **Hash 散列表**   
- **List 列表**


### redis的常用使用场景


- 缓存，毫无疑问这是Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；

- 排行榜，在使用传统的关系型数据库（mysql oracle 等）来做这个事儿，非常的麻烦，而利用Redis的SortSet(有序集合)数据结构能够简单的搞定；

- 计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；

- 好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；

- 简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；

- Session共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。

- 一些频繁被访问的数据，经常被访问的数据如果放在关系型数据库，每次查询的开销都会很大，而放在redis中，因为redis 是放在内存中的可以很高效的访问


### Redis的数据淘汰机制

- volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰  
- volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰  
- volatile-random从已设置过期时间的数据集中任意选择数据淘汰  
- allkeys-lru从所有数据集中挑选最近最少使用的数据淘汰  
- allkeys-random从所有数据集中任意选择数据进行淘汰  
- noeviction禁止驱逐数据

### Redis数据持久化

- RDB 持久化

> 将某个时间点的所有数据都存放到硬盘上。  
> 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。  
> 如果系统发生故障，将会丢失最后一次创建快照之后的数据。  
> 如果数据量很大，保存快照的时间会很长。  

- AOF 持久化

    将写命令添加到 AOF 文件（Append Only File）的末尾。

    使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：  
    
    - **always** 选项会严重减低服务器的性能；  

    选项同步频率always每个写命令都同步，everysec每秒同步一次，no让操作系统来决定何时同步  

    - **everysec**  选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；  

    - **no** 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量  

    随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。


### 分片

分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。  
假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。  

- 最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。  
- 还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。  


根据执行分片的位置，可以分为三种分片方式：  

- 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。  
- 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。  
- 服务器分片：Redis Cluster



----
<font size=2 color='grey'>本文收藏来自互联网，仅用于学习研究，著作权归原作者所有，如有侵权请联系删除</font>

markdown [@TsingChan](http://www.9ong.com/) 

> 引用格式为收藏注解，比如本句就是注解，非作者原文。
